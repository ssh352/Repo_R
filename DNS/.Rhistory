}))
test.vector
test.vector <- as.double(tail(total,b))
test.vector
b
test.vector <- as.double(head(tail(total,b),h))
test.vector
test.cor <- 100 - as.double(sapply(1:ncol(fcasts.all), function(i){
c <- cor(test.vector, as.double(fcasts.all[,i])) * 100
if (is.na(c)) {c <- 0}
return(c)
}))
test.cor
tail(fcasts.all)
fcasts.all[,39]
plot(fcasts.all[,39])
lines(fcasts.all[,39])
tail(total,3)
plot(tail(total,3))
err <- colSums(rbind(err,test.cor))
names(err) <- c(seq(-95,-5,5), 0, seq(5,95,5))
err
ix <- which(err==min(err))
#Ищем уровень с наименьшим расхождением
fc$tbats$level <- as.numeric(names(err)[ix])
#Запоминаем все эти данные
fc$tbats$sum <- sum(fcasts.all[,ix])
fc$tbats$mean <- c(tail(train,1),fcasts.all[,ix])
fc$tbats$error <- round(err[ix],1)
#ARIMA
fit.arima <- auto.arima(train, lambda=Lw)
fcast.arima <- forecast(fit.arima, h, lambda=Lw, level=c(seq(5,95,5)))
#Соберем вместе все прогнозы и посмотрим какой больше всего подходит
fcasts.mean <- as.vector(fcast.arima$mean)
dim(fcasts.mean) <- c(length(fcasts.mean),1)
fcasts.all <- data.frame(cbind(fcast.arima$lower, fcasts.mean, fcast.arima$upper))
fcasts.all <- apply(fcasts.all, 2, FUN=as.double)
#Смотрим насколько сходится по сумме прогноз
err <- abs(as.double(colSums(fcasts.all) / fc$sum * 100 - 100))
#Считаем корреляцию между настоящими данными и прогнозируемыми
test.vector <- as.double(head(tail(total,b),h))
test.cor <- 100 - as.double(sapply(1:ncol(fcasts.all), function(i){
cor(test.vector, as.double(fcasts.all[,i])) * 100
}))
err <- colSums(rbind(err,test.cor))
names(err) <- c(seq(-95,-5,5), 0, seq(5,95,5))
ix <- which(err==min(err))
#Ищем уровень с наименьшим расхождением
fc$arima$level <- as.numeric(names(err)[ix])
#Запоминаем все эти данные
fc$arima$sum <- sum(fcasts.all[,ix])
fc$arima$mean <- c(tail(train,1),fcasts.all[,ix])
fc$arima$error <- round(err[ix],1)
lim_start <- floor_date(date_end, "month") - months(b + 3)
if (h < 12) {
lim_end <- lim_start + months(12)
} else {
lim_end <- lim_start + months(h + 6)
}
plot(dates, total,
main = paste("Тестирование модели : ", main_text, sep=""), sub = NULL, xlab = xlab_text, ylab = ylab_text,
xlim=c(lim_start,lim_end), type="l", col=palette()[1])
lines(head(tail(dates,b+1), h+1),fc$arima$mean, type="l", col=palette()[2], lwd=3)
lines(head(tail(dates,b+1), h+1),fc$tbats$mean, type="l", col=palette()[3], lwd=3)
lines(dates, lowess(total)$y, type="l", lty="dashed", col=palette()[4])
#Добавляем линии для решетки
abline(h = axTicks(2),col="gray", lty="dashed")
abline(v = dates,col="gray", lty="dashed")
legend("topleft",
c("Реальные",
paste("ARIMA (",fc$arima$error,"%)", sep=""),
paste("TBATS (",fc$tbats$error,"%)", sep=""),
"Lowess"),
col=palette()[c(1:4)],
lty=c("solid","solid","solid","dashed"),
lwd=2,
cex=1)
################################
##  Прогноз                   ##
test.cor
err <- abs(as.double(colSums(fcasts.all) / fc$sum * 100 - 100))
names(err) <- c(seq(-95,-5,5), 0, seq(5,95,5))
err
fc$arima$level
fcast_monthly <- function(zoo_series, fcast.period = 3, test.period = 3,
main_text = NULL, xlab_text = NULL, ylab_text = NULL) {
h <- fcast.period
b <- test.period
#Создаем векторы с датами, для тестирования и для прогнозирования
dates <- index(zoo_series)
#Обрезаем неполный месяц в конце
if (Sys.Date() < tail(dates, 1)) {
dates <- head(dates,-1)
zoo_series <- head(zoo_series, -1)
}
fdates <- c(dates, last_day(floor_date(tail(dates,1), "month")+ months(1:(h))))
#Запоминаем начальные даты в формате вектора и в обычном
date_start_ts <- as.double(unlist(strsplit(as.character(start(zoo_series)), "-")))
date_start <- start(zoo_series)
date_end <- end(zoo_series)
#Создаем TS из zoo серии
total <- ts(zoo_series, start=date_start_ts, frequency = 12)
################################
##  Обзорные графики          ##
################################
#общая картина по продажам циски
plot(dates, total,
main = main_text, sub = NULL, xlab = xlab_text, ylab = ylab_text,
type="l", col=palette()[1])
lines(dates, lowess(total)$y, type="l", lty="dashed", col=palette()[2])
#Добавляем линии для решетки
abline(h = axTicks(2),col="gray", lty="dashed")
abline(v = dates[seq(3, length(dates), 3)],col="gray", lty="dashed")
legend("topleft",
c("Реальные", "lowess"),
col=c("black","red"),
lty=c("solid","dashed"),
lwd=2,
cex=1)
#Сначала рисуем общие данные по продажам
plot(stl(total, s.window = "periodic"))
mtext(ylab_text,side=3,outer=F, cex=1, line=2, adj=0.5)
################################
##  Проверяем модель          ##
################################
print("Строим тестовую модель")
#Учим модель и делаем тестовый прогноз
train <- ts(head(total, -b), start=date_start_ts, frequency = 12)
#однопараметрическое преобразование Бокса-Кокса (пока не очень понимаю что это)
Lw <- BoxCox.lambda(train, method="loglik")
fc <- list()
fc$tbats <- list()
fc$arima <- list()
fc$sum <- sum(head(tail(total,b),h))
#Предсказываем на тестовом наборе
#Посчитаем размер ошибки для обоих предсказаний
#TBATS
fit.tbats <- tbats(train, lambda=Lw)
fcast.tbats <- forecast(fit.tbats, h, lambda=Lw, level=c(seq(5,95,5)))
#Соберем вместе все прогнозы и посмотрим какой больше всего подходит
fcasts.mean <- as.vector(fcast.tbats$mean)
dim(fcasts.mean) <- c(length(fcasts.mean),1)
fcasts.all <- data.frame(cbind(fcast.tbats$lower, fcasts.mean, fcast.tbats$upper))
fcasts.all <- apply(fcasts.all, 2, FUN=as.double)
#Смотрим насколько сходится по сумме прогноз
err <- abs(as.double(colSums(fcasts.all) / fc$sum * 100 - 100))
#Считаем корреляцию между настоящими данными и прогнозируемыми
#test.vector <- as.double(head(tail(total,b),h))
#test.cor <- 100 - as.double(sapply(1:ncol(fcasts.all), function(i){
#cor(test.vector, as.double(fcasts.all[,i])) * 100
#}))
#Теперь сводим сумму по предсказанию и корреляцию
#err <- colSums(rbind(err,test.cor))
names(err) <- c(seq(-95,-5,5), 0, seq(5,95,5))
ix <- which(err==min(err))
#Ищем уровень с наименьшим расхождением
fc$tbats$level <- as.numeric(names(err)[ix])
#Запоминаем все эти данные
fc$tbats$sum <- sum(fcasts.all[,ix])
fc$tbats$mean <- c(tail(train,1),fcasts.all[,ix])
fc$tbats$error <- round(err[ix],1)
#ARIMA
fit.arima <- auto.arima(train, lambda=Lw)
fcast.arima <- forecast(fit.arima, h, lambda=Lw, level=c(seq(5,95,5)))
#Соберем вместе все прогнозы и посмотрим какой больше всего подходит
fcasts.mean <- as.vector(fcast.arima$mean)
dim(fcasts.mean) <- c(length(fcasts.mean),1)
fcasts.all <- data.frame(cbind(fcast.arima$lower, fcasts.mean, fcast.arima$upper))
fcasts.all <- apply(fcasts.all, 2, FUN=as.double)
#Смотрим насколько сходится по сумме прогноз
err <- abs(as.double(colSums(fcasts.all) / fc$sum * 100 - 100))
#Считаем корреляцию между настоящими данными и прогнозируемыми
#test.vector <- as.double(head(tail(total,b),h))
#test.cor <- 100 - as.double(sapply(1:ncol(fcasts.all), function(i){
#cor(test.vector, as.double(fcasts.all[,i])) * 100
#}))
#Теперь сводим сумму по предсказанию и корреляцию
#err <- colSums(rbind(err,test.cor))
names(err) <- c(seq(-95,-5,5), 0, seq(5,95,5))
ix <- which(err==min(err))
#Ищем уровень с наименьшим расхождением
fc$arima$level <- as.numeric(names(err)[ix])
#Запоминаем все эти данные
fc$arima$sum <- sum(fcasts.all[,ix])
fc$arima$mean <- c(tail(train,1),fcasts.all[,ix])
fc$arima$error <- round(err[ix],1)
lim_start <- floor_date(date_end, "month") - months(b + 3)
if (h < 12) {
lim_end <- lim_start + months(12)
} else {
lim_end <- lim_start + months(h + 6)
}
plot(dates, total,
main = paste("Тестирование модели : ", main_text, sep=""), sub = NULL, xlab = xlab_text, ylab = ylab_text,
xlim=c(lim_start,lim_end), type="l", col=palette()[1])
lines(head(tail(dates,b+1), h+1),fc$arima$mean, type="l", col=palette()[2], lwd=3)
lines(head(tail(dates,b+1), h+1),fc$tbats$mean, type="l", col=palette()[3], lwd=3)
lines(dates, lowess(total)$y, type="l", lty="dashed", col=palette()[4])
#Добавляем линии для решетки
abline(h = axTicks(2),col="gray", lty="dashed")
abline(v = dates,col="gray", lty="dashed")
legend("topleft",
c("Реальные",
paste("ARIMA (",fc$arima$error,"%)", sep=""),
paste("TBATS (",fc$tbats$error,"%)", sep=""),
"Lowess"),
col=palette()[c(1:4)],
lty=c("solid","solid","solid","dashed"),
lwd=2,
cex=1)
################################
##  Прогноз                   ##
################################
print("Считаем прогноз")
Lw <- BoxCox.lambda(total, method="loglik")
#Предсказываем на тестовом наборе
#Посчитаем размер ошибки для обоих предсказаний
#TBATS
fit.tbats <-tbats(total, lambda=Lw)
fcast.tbats <- forecast(fit.tbats, h, lambda=Lw, level=abs(fc$tbats$level))
if (fc$tbats$level > 0) {
fc$tbats$mean <- c(tail(total,1),as.numeric(fcast.tbats$upper))
} else {
fc$tbats$mean <- c(tail(total,1),as.numeric(fcast.tbats$lower))
}
#ARIMA
fit.arima <- auto.arima(total, lambda=Lw)
fcast.arima <- forecast(fit.arima, h, lambda=Lw, level=abs(fc$arima$level))
if (fc$arima$level > 0) {
fc$arima$mean <- c(tail(total,1),as.numeric(fcast.arima$upper))
} else {
fc$arima$mean <- c(tail(total,1),as.numeric(fcast.arima$lower))
}
lim_start <- end_date - years(1)
lim_end <- last_day(floor_date(end_date,"month") + months(h+1))
plot(dates, total,
main = paste("Прогноз : ", main_text, sep=""), sub = NULL, xlab = xlab_text, ylab = ylab_text,
axes=FALSE,
xlim=c(lim_start,lim_end), type="l", col=palette()[1])
axis(side=2)
axis(side=1, at = fdates, labels = substr(as.character(fdates),3,7), las=2)
box()
#Добавляем линии для решетки
abline(h = axTicks(2),col="gray", lty="dashed")
abline(v = fdates,col="gray", lty="dashed")
lines(tail(fdates,h+1),fc$arima$mean, type="l", col=palette()[2], lwd=3)
lines(tail(fdates,h+1),fc$tbats$mean, type="l", col=palette()[3], lwd=3)
lines(dates, lowess(total)$y, type="l", lty="dashed", col=palette()[4])
legend("topleft",
c("Реальные",
paste("ARIMA (",fc$arima$error,"%)", sep=""),
paste("TBATS (",fc$tbats$error,"%)", sep=""),
"Lowess"),
col=palette()[c(1:4)],
lty=c("solid","solid","solid","dashed"),
lwd=2,
cex=1)
if (fc$arima$error <= fc$tbats$error) {
print("Процент ошибки меньшу у ARIMA")
} else {
print("Процент ошибки меньшу у TBATS")
}
return(
list(
arima=tail(fc$arima$mean, -1),
arima_err=fc$arima$error,
tbats=tail(fc$tbats$mean, -1),
tbats_error=fc$tbats$error)
)
}
fcast <- fcast_monthly(zoo_series = apply.monthly(sales_daily[[1]], FUN=sum), fcast.period = 6, test.period = 6,
main_text = "клин", ylab_text = "Продажи (Тыс.р.)", xlab_text = "Время")
fcast <- fcast_monthly(zoo_series = apply.monthly(sales_daily[[4]], FUN=sum), fcast.period = 6, test.period = 6,
main_text = "клин", ylab_text = "Продажи (Тыс.р.)", xlab_text = "Время")
stl(apply.monthly(sales_daily[[4]])
)
stl(apply.monthly(sales_daily[[4]], s.window = 1)
)
is.period(sales_daily[[4]])
is.period(sales_daily[[1]])
fcast_monthly <- function(zoo_series, fcast.period = 3, test.period = 3,
main_text = NULL, xlab_text = NULL, ylab_text = NULL) {
h <- fcast.period
b <- test.period
#Создаем векторы с датами, для тестирования и для прогнозирования
dates <- index(zoo_series)
#Обрезаем неполный месяц в конце
if (Sys.Date() < tail(dates, 1)) {
dates <- head(dates,-1)
zoo_series <- head(zoo_series, -1)
}
fdates <- c(dates, last_day(floor_date(tail(dates,1), "month")+ months(1:(h))))
#Запоминаем начальные даты в формате вектора и в обычном
date_start_ts <- as.double(unlist(strsplit(as.character(start(zoo_series)), "-")))
date_start <- start(zoo_series)
date_end <- end(zoo_series)
#Создаем TS из zoo серии
total <- ts(zoo_series, start=date_start_ts, frequency = 12)
################################
##  Обзорные графики          ##
################################
#общая картина по продажам циски
plot(dates, total,
main = main_text, sub = NULL, xlab = xlab_text, ylab = ylab_text,
type="l", col=palette()[1])
lines(dates, lowess(total)$y, type="l", lty="dashed", col=palette()[2])
#Добавляем линии для решетки
abline(h = axTicks(2),col="gray", lty="dashed")
abline(v = dates[seq(3, length(dates), 3)],col="gray", lty="dashed")
legend("topleft",
c("Реальные", "lowess"),
col=c("black","red"),
lty=c("solid","dashed"),
lwd=2,
cex=1)
#Сначала рисуем общие данные по продажам
if (length(zoo_series)>=24) {
plot(stl(total, s.window = "periodic"))
mtext(ylab_text,side=3,outer=F, cex=1, line=2, adj=0.5)
}
################################
##  Проверяем модель          ##
################################
print("Строим тестовую модель")
#Учим модель и делаем тестовый прогноз
train <- ts(head(total, -b), start=date_start_ts, frequency = 12)
#однопараметрическое преобразование Бокса-Кокса (пока не очень понимаю что это)
Lw <- BoxCox.lambda(train, method="loglik")
fc <- list()
fc$tbats <- list()
fc$arima <- list()
fc$sum <- sum(head(tail(total,b),h))
#Предсказываем на тестовом наборе
#Посчитаем размер ошибки для обоих предсказаний
#TBATS
fit.tbats <- tbats(train, lambda=Lw)
fcast.tbats <- forecast(fit.tbats, h, lambda=Lw, level=c(seq(5,95,5)))
#Соберем вместе все прогнозы и посмотрим какой больше всего подходит
fcasts.mean <- as.vector(fcast.tbats$mean)
dim(fcasts.mean) <- c(length(fcasts.mean),1)
fcasts.all <- data.frame(cbind(fcast.tbats$lower, fcasts.mean, fcast.tbats$upper))
fcasts.all <- apply(fcasts.all, 2, FUN=as.double)
#Смотрим насколько сходится по сумме прогноз
err <- abs(as.double(colSums(fcasts.all) / fc$sum * 100 - 100))
#Считаем корреляцию между настоящими данными и прогнозируемыми
#test.vector <- as.double(head(tail(total,b),h))
#test.cor <- 100 - as.double(sapply(1:ncol(fcasts.all), function(i){
#cor(test.vector, as.double(fcasts.all[,i])) * 100
#}))
#Теперь сводим сумму по предсказанию и корреляцию
#err <- colSums(rbind(err,test.cor))
names(err) <- c(seq(-95,-5,5), 0, seq(5,95,5))
ix <- which(err==min(err))
#Ищем уровень с наименьшим расхождением
fc$tbats$level <- as.numeric(names(err)[ix])
#Запоминаем все эти данные
fc$tbats$sum <- sum(fcasts.all[,ix])
fc$tbats$mean <- c(tail(train,1),fcasts.all[,ix])
fc$tbats$error <- round(err[ix],1)
#ARIMA
fit.arima <- auto.arima(train, lambda=Lw)
fcast.arima <- forecast(fit.arima, h, lambda=Lw, level=c(seq(5,95,5)))
#Соберем вместе все прогнозы и посмотрим какой больше всего подходит
fcasts.mean <- as.vector(fcast.arima$mean)
dim(fcasts.mean) <- c(length(fcasts.mean),1)
fcasts.all <- data.frame(cbind(fcast.arima$lower, fcasts.mean, fcast.arima$upper))
fcasts.all <- apply(fcasts.all, 2, FUN=as.double)
#Смотрим насколько сходится по сумме прогноз
err <- abs(as.double(colSums(fcasts.all) / fc$sum * 100 - 100))
#Считаем корреляцию между настоящими данными и прогнозируемыми
#test.vector <- as.double(head(tail(total,b),h))
#test.cor <- 100 - as.double(sapply(1:ncol(fcasts.all), function(i){
#cor(test.vector, as.double(fcasts.all[,i])) * 100
#}))
#Теперь сводим сумму по предсказанию и корреляцию
#err <- colSums(rbind(err,test.cor))
names(err) <- c(seq(-95,-5,5), 0, seq(5,95,5))
ix <- which(err==min(err))
#Ищем уровень с наименьшим расхождением
fc$arima$level <- as.numeric(names(err)[ix])
#Запоминаем все эти данные
fc$arima$sum <- sum(fcasts.all[,ix])
fc$arima$mean <- c(tail(train,1),fcasts.all[,ix])
fc$arima$error <- round(err[ix],1)
lim_start <- floor_date(date_end, "month") - months(b + 3)
if (h < 12) {
lim_end <- lim_start + months(12)
} else {
lim_end <- lim_start + months(h + 6)
}
plot(dates, total,
main = paste("Тестирование модели : ", main_text, sep=""), sub = NULL, xlab = xlab_text, ylab = ylab_text,
xlim=c(lim_start,lim_end), type="l", col=palette()[1])
lines(head(tail(dates,b+1), h+1),fc$arima$mean, type="l", col=palette()[2], lwd=3)
lines(head(tail(dates,b+1), h+1),fc$tbats$mean, type="l", col=palette()[3], lwd=3)
lines(dates, lowess(total)$y, type="l", lty="dashed", col=palette()[4])
#Добавляем линии для решетки
abline(h = axTicks(2),col="gray", lty="dashed")
abline(v = dates,col="gray", lty="dashed")
legend("topleft",
c("Реальные",
paste("ARIMA (",fc$arima$error,"%)", sep=""),
paste("TBATS (",fc$tbats$error,"%)", sep=""),
"Lowess"),
col=palette()[c(1:4)],
lty=c("solid","solid","solid","dashed"),
lwd=2,
cex=1)
################################
##  Прогноз                   ##
################################
print("Считаем прогноз")
Lw <- BoxCox.lambda(total, method="loglik")
#Предсказываем на тестовом наборе
#Посчитаем размер ошибки для обоих предсказаний
#TBATS
fit.tbats <-tbats(total, lambda=Lw)
fcast.tbats <- forecast(fit.tbats, h, lambda=Lw, level=abs(fc$tbats$level))
if (fc$tbats$level > 0) {
fc$tbats$mean <- c(tail(total,1),as.numeric(fcast.tbats$upper))
} else {
fc$tbats$mean <- c(tail(total,1),as.numeric(fcast.tbats$lower))
}
#ARIMA
fit.arima <- auto.arima(total, lambda=Lw)
fcast.arima <- forecast(fit.arima, h, lambda=Lw, level=abs(fc$arima$level))
if (fc$arima$level > 0) {
fc$arima$mean <- c(tail(total,1),as.numeric(fcast.arima$upper))
} else {
fc$arima$mean <- c(tail(total,1),as.numeric(fcast.arima$lower))
}
lim_start <- end_date - years(1)
lim_end <- last_day(floor_date(end_date,"month") + months(h+1))
plot(dates, total,
main = paste("Прогноз : ", main_text, sep=""), sub = NULL, xlab = xlab_text, ylab = ylab_text,
axes=FALSE,
xlim=c(lim_start,lim_end), type="l", col=palette()[1])
axis(side=2)
axis(side=1, at = fdates, labels = substr(as.character(fdates),3,7), las=2)
box()
#Добавляем линии для решетки
abline(h = axTicks(2),col="gray", lty="dashed")
abline(v = fdates,col="gray", lty="dashed")
lines(tail(fdates,h+1),fc$arima$mean, type="l", col=palette()[2], lwd=3)
lines(tail(fdates,h+1),fc$tbats$mean, type="l", col=palette()[3], lwd=3)
lines(dates, lowess(total)$y, type="l", lty="dashed", col=palette()[4])
legend("topleft",
c("Реальные",
paste("ARIMA (",fc$arima$error,"%)", sep=""),
paste("TBATS (",fc$tbats$error,"%)", sep=""),
"Lowess"),
col=palette()[c(1:4)],
lty=c("solid","solid","solid","dashed"),
lwd=2,
cex=1)
if (fc$arima$error <= fc$tbats$error) {
print("Процент ошибки меньшу у ARIMA")
} else {
print("Процент ошибки меньшу у TBATS")
}
return(
list(
arima=tail(fc$arima$mean, -1),
arima_err=fc$arima$error,
tbats=tail(fc$tbats$mean, -1),
tbats_error=fc$tbats$error)
)
}
fcast <- fcast_monthly(zoo_series = apply.monthly(sales_daily[[1]], FUN=sum), fcast.period = 6, test.period = 6,
main_text = "клин", ylab_text = "Продажи (Тыс.р.)", xlab_text = "Время")
fcast <- fcast_monthly(zoo_series = apply.monthly(sales_daily[[4]], FUN=sum), fcast.period = 6, test.period = 6,
main_text = "клин", ylab_text = "Продажи (Тыс.р.)", xlab_text = "Время")
fcast <- fcast_monthly(zoo_series = apply.monthly(sales_daily[[4]], FUN=sum), fcast.period = 3, test.period = 3,
main_text = "клин", ylab_text = "Продажи (Тыс.р.)", xlab_text = "Время")
window(sales_daily[[1]], end_date=start(sales_daily[[4]]))
start(sales_daily[[4]])
windows(sales_daily[[1]], end_date=start(sales_daily[[4]]))
window(sales_daily[[1]], start_date=start(sales_daily[[1]]), end_date=start(sales_daily[[4]]))
start(sales_daily[[1]])
typeof(start(sales_daily[[1]]))
as.Date(start(sales_daily[[1]]))
typeof(as.Date(start(sales_daily[[1]])))
class(start(sales_daily[[1]]))
window(sales_daily[[1]], start_date=start(sales_daily[[1]]), end_date=as.Date("2014-12-31"))
library(zoo)
window.zoo
window.zoo()
window(sales_daily[[1]], start_date=as.Date("2014-01-01"), end_date=as.Date("2014-12-31"))
window(sales_daily[[1]], start_date=c(2014,01,01), end_date=c(2014,12,31))
merge(sales_daily[[1]],sales_daily[[4]])
x <- data.frame(k1 = c(NA,NA,3,4,5), k2 = c(1,NA,NA,4,5), data = 1:5)
y <- data.frame(k1 = c(NA,2,NA,4,5), k2 = c(NA,NA,3,4,5), data = 1:5)
x
y
merge(x, y)
merge(sales_daily[[1]],sales_daily[[4]], all=T)
merge(sales_daily[[1]],sales_daily[[4]], all=TRUE)
merge(sales_daily[[4]],sales_daily[[1]], all=TRUE)
merge(sales_daily[[4]],sales_daily[[1]], all=FALSE)
length(sales_daily[[1]])
length(sales_daily[[4]])
head(sales_daily[[1]],-length(sales_daily[[4]]))
sales_daily[[4]])
sales_daily[[4]]
cbind(head(sales_daily[[1]],-length(sales_daily[[4]])),sales_daily[[4]]))
cbind(head(sales_daily[[1]],-length(sales_daily[[4]])),sales_daily[[4]])))
cbind(head(sales_daily[[1]],-length(sales_daily[[4]])),sales_daily[[4]])
rbind(head(sales_daily[[1]],-length(sales_daily[[4]])),sales_daily[[4]])
sales <- rbind(head(sales_daily[[1]],-length(sales_daily[[4]])),sales_daily[[4]])
plot(sales)
fcast <- fcast_monthly(zoo_series = apply.monthly(sales, FUN=sum), fcast.period = 3, test.period = 3,
main_text = "SPB", ylab_text = "Продажи (Тыс.р.)", xlab_text = "Время")
